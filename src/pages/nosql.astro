---
import Layout from "./layout.astro";
import { Image } from "astro:assets";
const bson: string =
`{
    "_id": 1,
    "title": "Geeksforgeeks",
    "author": "John Smith",
    "url": "https://www.geeksforgeeks.org/",
    "tags": ["NoSQL", "Database", "Tutorial"],
    "published": true,
    "views": 1500
  }`
const cassandra: string[] = [
  `CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    name text
  );`,
  `INSERT INTO users (user_id, name)
  VALUES (uuid(), 'Modi');`,
  `DELETE FROM users
  WHERE user_id = <some-uuid-here>;`,
];
const cypher: string[] = [
  `CREATE (:Person {name: 'Modi'}),
         (:Person {name: 'Aditi'});`,
  `// Delete one person and any relationships (safe way)
  MATCH (p:Person {name: 'Rahul'})
  DETACH DELETE p;`,
  `// Create a FRIENDS_WITH relationship between two people
  MATCH (a:Person {name: 'Anirudh'}),
        (b:Person {name: 'Aditi'})
  CREATE (a)-[:FRIENDS_WITH]->(b);`
];
---

<style>
    strong {
        color: red;
    }
</style>

<Layout title="NoSQL">
    <section id="overview" class="prose lg:prose-xl center min-w-screen p-5  text-white">
        <div id="logo">
            <Image
              src="https://i.ytimg.com/vi/t0GlGbtMTio/maxresdefault.jpg"
              alt="NoSQL vs SQL"
              inferSize
              layout="full-width"
            />
        </div>
        <h3>Traditional DBs (RDBs)</h3>
        <ul class="list-item list-none">
            <li>The Relational Model organizes data using tables (relations) consisting of rows and columns.</li>
            <ul>
                <li>
                    The relational model represents how data is stored and managed in Relational Databases where data is organized into tables, each known as a relation.
                </li>
                <li>
                    Each row of a table represents an entity or record and each column represents a particular attribute of that entity.
                </li>
                <li>
                    The relational model transforms conceptual designs from ER diagrams into implementable structures. These structures are used in relational database systems like Oracle SQL and MySQL.
                </li>
            </ul>
        </ul>
        <h3>SQL vs NoSQL</h3>
        <table>
            <thead>
                <tr><th><b><strong>Aspect</strong></b></th><th><b><strong>SQL (Relational)</strong></b></th><th><b><strong>NoSQL (Non-relational)</strong></b></th></tr>
            </thead>
            <tbody>
                <tr><td><b><strong>Data Structure</strong></b></td><td><span>Tables with rows and columns</span></td><td><span>Document-based, key-value, column-family, or graph-based</span></td></tr><tr><td><b><strong>Schema</strong></b></td><td><span>Fixed schema (predefined structure)</span></td><td><span>Flexible schema (dynamic and adaptable)</span></td></tr><tr><td><b><strong>Scalability</strong></b></td><td><span>Vertically scalable (upgrading hardware)</span></td><td><span>Horizontally scalable (adding more servers)</span></td></tr><tr><td><b><strong>Data Integrity</strong></b></td><td><span>ACID-compliant (strong consistency)</span></td><td><span>BASE-compliant (more available, less consistent)</span></td></tr><tr><td><b><strong>Query Language</strong></b></td><td><span>SQL (Structured Query Language)</span></td><td><span>Varies (e.g., MongoDB uses its own query language)</span></td></tr><tr><td><b><strong>Performance</strong></b></td><td><span>Efficient for complex queries and transactions</span></td><td><span>Better for large-scale data and fast read/write operations</span></td></tr><tr><td><b><strong>Use Case</strong></b></td><td><span>Best for transactional systems (banking, ERP, etc.)</span></td><td><span>Ideal for big data, real-time web apps, and data lakes</span></td></tr><tr><td><b><strong>Examples</strong></b></td><td><span>MySQL, PostgreSQL, Oracle, MS SQL Server</span></td><td><span>MongoDB, Cassandra, CouchDB, Neo4j</span></td></tr>
            </tbody>
        </table>
        <table>
            <thead><tr><th><span>NoSQL Database</span></th><th><span>Type</span></th><th><span>Use Cases</span></th></tr></thead><tbody><tr><td><b><strong>MongoDB</strong></b></td><td><span>Document-based</span></td><td><span>Content management, product catalogs</span></td></tr><tr><td><b><strong>Redis</strong></b></td><td><span>Key-Value Store</span></td><td><span>Caching, real-time analytics, session storage</span></td></tr><tr><td><b><strong>Cassandra</strong></b></td><td><span>Column-Family Store</span></td><td><span>Big data, high availability systems</span></td></tr><tr><td><b><strong>Neo4j</strong></b></td><td><span>Graph Database</span></td><td><span>Fraud detection, social networks</span></td></tr></tbody>
        </table>
    </section>
    <section id="nosql" class="prose lg:prose-xl center min-w-screen p-5  text-white">
        <h3>NoSQL</h3>
        <ul>
            <li>NoSQL (Not Only SQL) databases are designed to handle large volumes of unstructured and semi-structured data.</li>
            <li>
                Unlike traditional relational databases that rely on fixed schemas and tables, NoSQL offers flexible data models and supports horizontal scaling.
            </li>
            <li>
                This makes them well-suited for modern applications that require high performance, scalability, and the ability to manage diverse data types efficiently.
            </li>
        </ul>
        <h3>Features</h3>
        <ul>
            <li>
                Dynamic schema: Allow flexible shaping of data to meet new requirements without the need to migrate or change schemas.
            </li>
            <li>
                Horizontal scalability: Easily add more servers to handle increased load.
            </li>
            <li>
                Distributed and high availability: They are designed to be highly available and to automatically handle node failures and data replication across multiple nodes in a database cluster.
            </li>
            <li>
                Flexibility: Allow developers to store and retrieve data in a flexible and dynamic manner, with support for multiple data types and changing data structures.
            </li>
        </ul>
        <h3>Types</h3>
        <div id="logo">
            <Image
              src="https://media.geeksforgeeks.org/wp-content/uploads/20220405112418/NoSQLDatabases.jpg"
              alt="NoSQL Types"
              inferSize
              layout="full-width"
              priority
            />
        </div>
        <ul class="list-item list-none">
            <li>
                <table>
                    <thead><tr><th><span>Feature</span></th><th><span>Document-Based</span></th><th><span>Key-Value Store</span></th><th><span>Column-Oriented</span></th><th><span>Graph-Based</span></th></tr></thead><tbody><tr><td><b><strong>Data Model</strong></b></td><td><span>JSON-like documents</span></td><td><span>Key-Value pairs</span></td><td><span>Columns instead of rows</span></td><td><span>Nodes &amp; Relationships</span></td></tr><tr><td><b><strong>Best Use Case</strong></b></td><td><span>Semi-structured data</span></td><td><span>Fast lookups &amp; caching</span></td><td><span>Analytics &amp; big data</span></td><td><span>Relationship-heavy data</span></td></tr><tr><td><b><strong>Query Performance</strong></b></td><td><span>Moderate</span></td><td><span>Fast</span></td><td><span>High for analytics</span></td><td><span>Optimized for relationships</span></td></tr><tr><td><b><strong>Schema</strong></b></td><td><span>Flexible</span></td><td><span>Dynamic</span></td><td><span>Semi-structured</span></td><td><span>Schema-less</span></td></tr><tr><td><b><strong>Scalability</strong></b></td><td><span>Horizontal</span></td><td><span>High horizontal</span></td><td><span>Highly scalable</span></td><td><span>Scales with relationships</span></td></tr><tr><td><b><strong>Examples</strong></b></td><td><span>MongoDB, CouchDB</span></td><td><span>Redis, DynamoDB</span></td><td><span>Cassandra, HBase</span></td><td><span>Neo4j, Amazon Neptune</span></td></tr></tbody>
                </table>
            </li>
            <li>
                Document-Based Database
                <ul>
                    <li>
                        The document-based database is a nonrelational database. Instead of storing the data in rows and columns (tables), it uses the documents to store the data in the database. A document database stores data in JSON, BSON or XML documents.
                    </li>
                    <li>
                        Documents can be stored and retrieved in a form that is much closer to the data objects used in applications which means less translation is required to use these data in the applications.
                    </li>
                    <li>
                        Collections are the group of documents that store documents that have similar contents.
                    </li>
                    <li>
                        <table>
                            <thead><tr><th><span>Database</span></th><th><span>Use Case</span></th></tr></thead><tbody><tr><td><b><strong>MongoDB</strong></b></td><td><span>Content management, product catalogs, user profiles</span></td></tr><tr><td><b><strong>CouchDB</strong></b></td><td><span>Offline applications, mobile synchronization</span></td></tr><tr><td><b><strong>Firebase Firestore</strong></b></td><td><span>Real-time apps, chat applications</span></td></tr></tbody>
                        </table>
                    </li>
                </ul>
            </li>
            <li>
                Key-Value Store Database
                <ul>
                    <li>
                        The key-value store database is a nonrelational database. Instead of storing the data in rows and columns (tables), it uses the key-value pairs to store the data in the database. A key-value store database stores data in key-value pairs.
                    </li>
                    <li>
                        Key-value stores are used for caching, session management, and other applications where fast access to data is required.
                    </li>
                    <li>
                        <table>
                            <thead><tr><th><span>Database</span></th><th><span>Use Case</span></th></tr></thead><tbody><tr><td><b><strong>Redis</strong></b></td><td><span>Real-time analytics, caching, session management</span></td></tr><tr><td><b><strong>DynamoDB</strong></b></td><td><span>Scalable, highly available, low-latency</span></td></tr><tr><td><b><strong>Memcached</strong></b></td><td><span>High-performance caching</span></td></tr></tbody>
                        </table>
                    </li>
                </ul>
            </li>
            <li>
                Column Family Database
                <ul>
                    <li>
                        A column-oriented database is a non-relational database that stores the data in columns instead of rows.
                    </li>
                    <li>
                        That means when we want to run analytics on a small number of columns, we can read those columns directly without consuming memory with the unwanted data.
                    </li>
                    <li>
                        Columnar databases are designed to read data more efficiently and retrieve the data with greater speed. A columnar database is used to store a large amount of data.
                    </li>
                    <li>
                        <table>
                            <thead><tr><th><span>Database</span></th><th><span>Use Case</span></th></tr></thead><tbody><tr><td><b><strong>Apache Cassandra</strong></b></td><td><span>Real-time analytics, IoT applications</span></td></tr><tr><td><b><strong>Google Bigtable</strong></b></td><td><span>Large-scale machine learning, time-series data</span></td></tr><tr><td><b><strong>HBase</strong></b></td><td><span>Hadoop ecosystem, distributed storage</span></td></tr></tbody>
                        </table>
                    </li>
                </ul>
            </li>
            <li>
                Graph Database
                <ul>
                    <li>Graph-based databases focus on the relationship between the elements.</li>
                    <li>It stores the data in the form of nodes in the database. The connections between the nodes are called links or relationships, making them ideal for complex relationship-based queries.</li>
                    <li>Data is represented as nodes (objects) and edges (connections).</li>
                    <li>
                        <table>
                            <thead><tr><th><span>Database</span></th><th><span>Use Case</span></th></tr></thead><tbody><tr><td><b><strong>Neo4j</strong></b></td><td><span>Fraud detection, social networks</span></td></tr><tr><td><b><strong>Amazon Neptune</strong></b></td><td><span>Knowledge graphs, AI recommendations</span></td></tr><tr><td><b><strong>ArangoDB</strong></b></td><td><span>Multi-model database, cybersecurity</span></td></tr></tbody>
                        </table>
                    </li>
                </ul>
            </li>
        </ul>
    </section>
    <section id="laws" class="prose lg:prose-xl center min-w-screen p-5  text-white">
        <!-- ACID -->
        <h3>ACID</h3>
        <div id="logo">
            <Image
              src="https://media.geeksforgeeks.org/wp-content/uploads/20250728165405585326/acid_properties.webp"
              alt="ACID"
              inferSize
              layout="full-width"
              priority
            />
        </div>
        <ul>
            <li>
                Atomicity means a transaction is all-or-nothing either all its operations succeed, or none are applied. If any part fails, the entire transaction is rolled back to keep the database consistent.
            </li>
            <li>
                Consistency in transactions means that the database must remain in a valid state before and after a transaction.
            </li>
            <li>
                Isolation ensures that transactions run independently without affecting each other. Changes made by one transaction are not visible to others until they are committed.
            </li>
            <li>
                Durability ensures that once a transaction is committed, its changes are permanently saved, even if the system fails. The data is stored in non-volatile memory, so the database can recover to its last committed state without losing data.
            </li>
        </ul>
        <!-- CAP -->
        <h3>CAP Theorem</h3>
        <ul>
            <li>
                The CAP theorem is a fundamental concept in distributed systems theory that was first proposed by Eric Brewer in 2000 and subsequently shown by Seth Gilbert and Nancy Lynch in 2002.
            </li>
            <li>
                Consistency: It means that all the nodes (databases) inside a network will have the same copies of a replicated data item visible for various transactions.
            </li>
            <li>
                Availability means that each read or write request for a data item will either be processed successfully or will receive a message that the operation cannot be completed.
            </li>
            <li>
                Partition tolerance means that the system can continue operating even if the network connecting the nodes has a fault that results in two or more partitions, where the nodes in each partition can only communicate among each other. That means, the system continues to function and upholds its consistency guarantees in spite of network partitions.
            </li>
        </ul>
        <!-- BASE -->
        <h3>BASE Properties</h3>
        <ul>
            <li>
                Basically Available: This property refers to the fact that the database system should always be available to respond to user requests, even if it cannot guarantee immediate access to all data.
            </li>
            <li>
                Soft State: This property refers to the fact that the state of the database can change over time, even without any explicit user intervention. This can happen due to the effects of background processes, updates to data, and other factors.
            </li>
            <li>
                Eventually Consistent: the database should eventually converge to a consistent state, even if it takes some time for all updates to propagate and be reflected in the data.
            </li>
        </ul>
    </section>
    <section id="aggregate" class="prose lg:prose-xl center min-w-screen p-5  text-white">
        <!-- Overview -->
        <h3>Aggregate Model</h3>
        <ul>
            <li>Aggregate Model groups related data into a single, self-contained unit that the database reads and writes as one object.</li>
            <li>
                It mirrors real-world entities by keeping everything that belongs together in one place, avoiding scattered storage.
                This makes operations faster, simpler, and easier to scale across machines.
            </li>
            <li>
                Database touches one object instead of stitching pieces.
                Ideal for high-traffic apps where every millisecond counts.
                Reduces I/O chatter and keeps the system responsive.
            </li>
            <li>
                Each aggregate is independent enough to live on a different machine.
                No risky joins across nodes or tangled dependencies.
                Perfect fit for systems that grow like a spreading city.
            </li>
        </ul>
        <!-- Types -->
        <h3>Aggregate Data Types</h3>
        <ul class="list-item list-none">
            <li>
                Key Value Pair
                <div id="logo">
                    <Image
                      src="https://i.ytimg.com/vi/t0GlGbtMTio/maxresdefault.jpg"
                      alt="JSON"
                      inferSize
                      layout="full-width"
                      priority
                    />
                </div>
            </li>
            <li>
                Document
                <pre class="text-wrap">{bson}</pre>
            </li>
            <li>
                Column Family
                <div id="logo">
                    <Image
                        src="https://www.tutorialspoint.com/cassandra/images/cassandra_column_family.jpg"
                        alt="Column"
                        inferSize
                        layout="full-width"
                        priority
                    />
                </div>
            </li>
        </ul>
    </section>
    <section id="CQL" class="prose lg:prose-xl center min-w-screen p-5  text-white">
        <h3>Cassandra QL</h3>
        <ul>
            {cassandra.map((item) => (
            <li>
                <pre class="text-wrap">{item}</pre>
            </li>
            ))}
        </ul>
        <h3>Cypher QL</h3>
        <ul>
            {cypher.map((item) => (
            <li>
                <pre class="text-wrap">{item}</pre>
            </li>
            ))}
        </ul>
    </section>
</Layout>
